% тестовые значения  
a = 0; % левая граница интервала  
b = 2; % правая граница интервала  
gamma_1 = 1;   
gamma_2 = 3;  
phi_2 = 3;  
L = 2;

% основная сетка  
N = 8;   
h = [0.2, 0.4, 0.2, 0.4, 0.2, 0.2, 0.4];  
h_N = N-1;
x = zeros(N, 1);  
x(1) = a;  
for i = 2:N  
    x(i) = x(i-1) + h(i-1);  
end  

% функции-коэфициенты
k = @(x) 1;
q = @(x) 1;
f = @(x) 1;
tilda_h = @(i) (h(i)+h(i+1))/2;

% вспомогательная сетка  
half_x_N = N - 1; % количество точек на вспомогательной сетке  
half_h_N = half_x_N - 1; % количество шагов на вспомогательной сетке
half_x = zeros(half_x_N, 1); 
half_h = zeros(half_h_N, 1); 

% Заполнение значений узлов вспомогательной сетки  
for i = 1:half_x_N  
    half_x(i) = (x(i) + x(i + 1)) / 2; % середины интервалов x  
end  

% Заполнение массива шагов вспомогательной сетки 
for i = 1:half_h_N
    half_h(i) = (h(i) + h(i+1)) / 2; % средние значения h между соседними отрезками  
end  

% Вывод результатов для проверки  
disp('Основная сетка x:');  
disp(x);  
disp('Вспомогательная сетка half_x:');  
disp(half_x);  
disp('Шаги h_half:');  
disp(half_h);

% коэффициенты
a = zeros(N, 1);
b = zeros(N, 1);
c = zeros(N, 1);

% A * v = g
A = zeros(N);
v = zeros(N, 1);
g = zeros(N, 1);

% коэффициенты из разностной сетки для левой границы
b(1) = 0;
c(1) = 1;
g(1) = gamma_1;

% коэффициенты из разностной сетки для внутренних точек
for i = 1:N-2
    a(i+1) = -(k(half_x(i))/h(i));
    b(i+1) = -(k(half_x(i+1))/h(i+1));
    c(i+1) = k(half_x(i))/h(i) + k(half_x(i+1))/h(i+1) + tilda_h(i)*q(x(i+1)); %f(x(i+1))?
    g(i+1) = tilda_h(i)*f(x(i));
end

% коэффициенты из разностной сетки для правой границы
a(N) = -k(half_x(half_x_N))/h(length(h));
c(N) = k(half_x(half_x_N))/h(length(h)) + h(h_N)/2*q(x(N)) + phi_2;
g(N) = h(h_N)/2 * f(x(N)) + gamma_2;

% заполнение трёхдиагонльной матрицы: a - слева, с - на главной диагонали,
% b - справа
for i = 1:N
    A(i, i) = c(i); % центральная диагональ
    if i > 1  
        A(i,i-1) = a(i); % левая диагональ (начиная со второго элемента)  
    end  
    if i < N  
        A(i,i+1) = b(i); % правая диагональ (до предпоследнего элемента)  
    end  
end
    
% Печать результата  
disp('Трехдиагональная матрица коэффициентов A:');  
disp(A); 
disp('Вектор коэфициентов g');
disp(g);


% Метод прогонки  
% Прямой ход  
alpha = zeros(N, 1);  
beta = zeros(N, 1);  
alpha(1) = c(1); 
beta(1) = g(1); 

for i = 2:N  
    alpha(i) = c(i) - a(i) * b(i-1) / alpha(i-1);  
    beta(i) = g(i) - a(i) * beta(i-1) / alpha(i-1);  
end  

% Обратный ход  
v = zeros(N, 1);  
v(N) = beta(N) / alpha(N);  

for i = N-1:-1:1  
    v(i) = (beta(i) - b(i) * v(i+1)) / alpha(i);  
end  

plot(x, v)
xlabel('x (длина бруса)');  
ylabel('Температура V(x)');
title('Распределение температуры в брусе');
xticks(half_x); % нанесём вспомогательную сетку на ось х 
xticklabels(arrayfun(@num2str, half_x, 'UniformOutput', false));  

grid on; 